package main


import (
	"fmt"
	"strconv"
	"time"
	"runtime"
)

	// 需求,要求统计1-2000000000的数字中,哪些是素数
	// 思路分析
		// 传统方法,使用一个循环,判断哥哥数字是不是素数,除了1跟自身,不能被别的整数除尽
		// 使用并发或者并行的方式,将统计素数的任务分配给多个goroutine(协程)去完成
	// 进程和线程的说明
		// 进程就是程序在操作系统中的一次执行过程,是系统进行资源分配和调度的单位
		// 线程是进程的一个执行实例,是程序执行的最小单位,它比进程更小的能独立运行的基本单位
		// 一个进程可以创建多个线程,同一个进程的多个线程,可以并发执行
		// 一个程序至少有一个进程,一个进程至少有一个线程
	// 并发和并行
		// 多线程程序在单核上运行,就是并发
		// 多线程在多核上运行就是并行
		// 并发: 一个CPU上有多个线程,其实某一个时刻只有一个线程在执行
		// 并行: 多个CPU,各个有好几个线程,每个线程在各自不同的CPU上执行,某一个时间点,是CPU个数那么多的线程在执行
	// go协程和go主线程, 在go中一个线程可以跑上千万个协程
		// Go主线程(有程序员直接称之为线程/也可以理解为进程), 一个Go线程上,可以起多个协程,协程是轻量级的线程
		// Go协程的特点:  有独立的栈空间, 共享程序堆空间, 调度由用户控制, 协程是轻量级的线程
	// goroutine
		// 主线程是一个物理线程,直接作用在CPU上的,是重量级的,非常耗费CPU资源
		// 协程从主线程开启的,是轻量级的线程,是逻辑态, 对资源消耗相对小
		// golang的协程机制是重要的特点,可以轻松开启上万个协程,其他变成语言的并发机制是一般用于线程的,开启过多的线程,资源耗费大,所以Golang在并发上很有优势
	// MPG模式基本介绍
		// M: 操作系统的主线程(是物理线程)
		// P: 协程执行需要的上下文环境,运行的时候需要的资源,或者操作系统的状态
		// G: 协程
func test() {
	for i := 1; i <= 10; i++ {
		fmt.Println("hello world~~~" + strconv.Itoa(i))
		time.Sleep(time.Second)
	}

}


func main() {
	// 快速入门案例
		// 在主线程中,开启一个goroutine,该协程每隔1秒输出"hello world~~"
		// 在主线程中也每隔一秒中输出一个"hello golang~~~",输出10次后退出程序
		// 要求主线程和goroutine同时执行
		// 画出主线程和协程执行流程图
	go test()  // 开启了一个协程,以主线程退出为主
	for i := 1; i <= 10; i++ {
		fmt.Println("hello golang~~~" + strconv.Itoa(i))
		time.Sleep(time.Second)
	}

	// 设置go运行的CPU的个数, runtime包, 
		// NumCPU:返回本地机器逻辑的CPU个数 
		// GOMAXPROCS: 设置可同时执行的最大CPU,并返回先前的设置
	cpuNum := runtime.NumCPU()
	fmt.Println(cpuNum)  // 4
	// 可以自己设置使用多少个CPU
	runtime.GOMAXPROCS(cpuNum - 1)
	
}